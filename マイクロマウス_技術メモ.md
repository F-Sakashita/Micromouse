# 目的

- マイクロマウスを設計する際の備忘録をここに残す．技術範囲はマイクロマウス 限定でも良い．わかったこと，疑問に思っていること，何でもいいのでメモする．記入ルールとしてはカテゴリ別に分けるだけで，あとは自由．参考にしたURLや書籍の情報，なぜその設計にしたのかは必ずメモすること．



## マウス用語

- マウス本：苦しんで作るマイクロマウス 





# 回路

### Kicad

- 回路ごとで階層シートを分けると見やすい．
  - MCUの回路の下層に電源，モータ駆動，壁センサのシートを作成し，それぞれに階層ラベルを追加した．

## 回路設計

###  回路部品

#### チップ抵抗

-  チップサイズが大きくなるにつれて最大電力が増えていく．1608サイズだと1/10W．定格電力の1/2以下の消費電力で使用する．[抵抗器の基礎知識：ROHM株式会社](https://www.rohm.co.jp/electronics-basics/resistors/r_what1)

#### チップコンデンサ

- セラミックコンデンサの場合，チップサイズが大きくなるにつれて耐圧が増える．一般的に耐圧と容量はトレードオフの関係．耐圧が増える→容量が小さい
  - 村田のラインナップがわかりやすい．選定の参考になる．[一般用チップ積層セラミックコンデンサ：村田製作所](https://www.murata.com/ja-jp/products/capacitor/ceramiccapacitor/smd/grm)

### 駆動回路

- Faulhaber1717T003SRの定格時の起動電流は2.712 A (= 起動トルク/トルク定数より算出)，連続電流0.7A
  - トルク定数：1.98 mNm/A,  起動トルク：5.47 mNm
- MDはモータの起動電流，連続電流を超えるように，TB6612FNGを採用（平均1.2A, ピーク3.2A)
- ただ定格電圧3Vに対して，MDの電源電圧が最大8.4Vと定格の2倍以上・・・出力制限するのかな・・・？定格6Vのモータに変更にするべき？
  - 6Vの場合，起動電流1.35A, 連続0.63A．定常時のトルクは3Vより大きいが回転数が劣る．逆起電圧も大きい．3Vよりちょい高価．[2019年のテクニカルデータ集](http://www.ntf.or.jp/mouse/micromouse2019/result/mm2019recode_v104.pdf)には両方いる・・・まじで定格2倍以上で使用してるのか？
    - まじだった（3Vに3セルとか突っ込んでる・・・）[マウサーの方のTwitter](https://twitter.com/tennisyi/status/802868693659099137)

### 発光回路

- マウス本をほぼ真似た．オペアンプ の入力信号の分圧回路を3.3Vに合わせた．電流量の計算は回路図に記載．

### 受光回路

- フォトトランジスタの負荷抵抗を1k にしたが，なぜ1kという値が良いのか，マイコンからはこの信号がどう見えるのかが不明．下記の参考ページと同じ回路を採用．実機で動作確認する．
  - 負荷抵抗を1kにした時のAD値の算出について調べること
  - 参考：https://rt-net.jp/mobility/archives/14559

## 基板設計

### パターン幅, ビア径

- 1mm = 1A,   

### 電源回路

- パターン幅はなるべく太く．ベタでやったほうが良さげ？
  - 例えば[このマウサーの方のブログ](https://nout.hatenadiary.jp/entry/2018/05/17/161537)にあるAWを見ると，モータ電源のVCCはかなり太いベタ配線．
  - モータ1つで連続1.0Aなため，最低で4Aくらいは流せるくらいパターン幅(4mmくらい)を確保したほうが良い？

### 駆動回路

- パターン幅はモータの連続電流量を超える太さにする．連続1.0Aくらいになるだろう

### 回路Version

#### V1.0 

- 2020/12に発注
- 電源スイッチ回路のバグを発見
- 5V->3.3Vのレギュレータの選定を誤っていた．購入したレギュレータとのピン配置が異なっており，電源投入後ショートの状態になっている
- 電源スイッチのON方向を表すシルクが，選定したスイッチのものと方向が逆

#### V1.1

- 2021/1に発注

- 電源回路周辺を修正．シルクを修正

- 書き込み，LED，スイッチ，壁センサ，エンコーダ，バッテリモニタ，ジャイロ

- シルクが一部反映されていなかった．

- USB-Serial変換モジュールを指す向きが反対になるようなピン配置だった
  - 縦向きに指す予定なのでこのままでOK
  - ただ，無線通信モジュールが取り付けられるようにした方がよい．要検討．
  
- リセットボタン・モードボタンが押しにくい．LEDの位置が指に被り見えにくい

- スイッチの向きを逆にしたい（機体内側に倒すとON状態）

- STLINKが差しにくい．コネクタを選定するか，NucleoのSTLinkをそのまま挿せるようにするとか．SHコネクタが良さそう

- ブザーのピンがPWM使えない

- 壁センサの固定パーツがあった方が良い．指向性がぶれる

- タイヤ軸のネジ固定のナットがモータと干渉し，ナットが取り付けられない

- タイヤのベアリング部の直径が緩く，ベアリングが簡単に取れてしまう

- I2Cのテストピンはいらない

- 電源コネクタがバッテリーと極性が逆だった・・・

- STM32のLTが48weekと頭がおかしいことになってるので，家にあるSTM32F407VGT6を検討する(ただしLQFP100なのでF405RGよりデカイ)

  

# ソフト

## 組込

### SPI

- SDI : SPI serial data input = MISO
- SDO : SPI serial data output = MOSI
- SPI mode 0 :
  - CPOL=0 : アイドル状態のCLKがLow
  - CPHA=0 :  データを立ち上がりでサンプリング（Read），立ち下がりでシフト（Write）
- SPI mode 1 : 
  - CPOL=0 : アイドル状態のCLKがLow
  - CPHA=1 :  データを立ち下がりでサンプリング（Read），立ち上がりでシフト（Write）
- SPI mode 2 :
  - CPOL=1 : アイドル状態のCLKがHigh
  - CPHA=0 :  データを立ち上がりでサンプリング（Read），立ち下がりでシフト（Write）
- SPI mode 3 : 
  - CPOL=1 : アイドル状態のCLKがHigh
  - CPHA=1 :  データを立ち下がりでサンプリング（Read），立ち上がりでシフト（Write）

[SPI通信:AnalogDevices](https://www.analog.com/jp/analog-dialogue/articles/introduction-to-spi-interface.html#)

### ICM-20602

- SPIは最大10MHz, MSB first
- SPI modeは
  - CLKがアイドル時High

### STM32

#### printf

https://garberas.com/archives/99

#### Flash ROM



#### CMSIS DSP (Digital Signal Processor)

ARM社提供の高速演算処理装置

FPUは使わなくても使える？が，FPUを使ったほうが速くなる（多分）

<img src="/Users/fumihiko-mbp/Library/Application Support/typora-user-images/image-20210421003223658.png" alt="image-20210421003223658" style="zoom:50%;" />



<img src="/Users/fumihiko-mbp/Library/Application Support/typora-user-images/image-20210421003246301.png" alt="image-20210421003246301" style="zoom:50%;" />



<img src="/Users/fumihiko-mbp/Library/Application Support/typora-user-images/image-20210421003121294.png" alt="image-20210421003121294" style="zoom:50%;" />





#### FPU (浮動小数点ユニット）

浮動小数点演算専用の処理装置．

Floating-point unit：FPUを有効にするかどうかを設定．

​    None : FPU無効

​    FPv4-SP-D16 :   FPU有効  

Floating-point ABI：

​	soft : 浮動小数点演算ライブラリ(soft-float)を使用

​	softfp : 浮動小数点演算に浮動小数点演算命令を使用する（つまりFPUを使用する）が，引数にfloatがある関数の呼び出しには汎用レジスタを使って値を渡す

​	hard :  浮動小数点演算に浮動小数点演算命令を使用する（つまりFPUを使用する），また引数にfloatがある関数には浮動小数点レジスタを使って値を渡す（つまりFPUを使用する）

なお，STM32でFPUを使用する場合は，ビルド設定にて追加でシンボル定義欄に「__FPU_PRESENT=1」を定義する必要がある（stm32fxxx.hにいるのだが，インクルードの順番によりcore_cm4.hでエラーとなってしまう．

また，使用する場合，1.0fや0.0fと，値の後ろにfを付与する必要がある．

Ref : http://meerstern.seesaa.net/article/477959771.html



### FreeRTOS (CMSIS V2)

Reference : 

http://www.azusa-st.com/kjm/FreeRtos/API/configuration.html

[Chapter3 タスク管理(FreeRTOSチュートリアル)](https://qiita.com/azuki_bar/items/99e653a59b9ad0176179)

#### MPU/FPU

​	ENABLE_MPU : FreeRTOS内のMemory Protection Unitの有効化 (FreeRTOS Native API？のみサポート)

​	ENABLE_FPU : FreeRTOSでFPUの有効化

#### Kernel settings

 1. USE_PREEMPTION : Preemption(プリエンプション)の有効化，あるタスクから別タスクへ強制的に切り替えること

 2. CPU_CLOCK_HZ : CPUのクロック周波数．変更不可？

 3. TICK_RATE_HZ : Tickの割り込み周波数．1〜1000まで．単位はHz

 4. MAX_PRIORITIES : タスクの最大優先度．CMSIS V2の場合は56固定．タスク優先度は0(優先度最低)からMAX_PRIORITIES-1（優先度最大）まで

 5. MINIMAL_STACK_SIZE : スタックの最小サイズ，64Words~3.84kWords. 

    各タスクに割り当てるスタック（関数内のオート変数など）のサイズ．

    スタックサイズの合計＜ヒープサイズの合計にする必要がある．

    最大値：ヒープサイズの合計/ 4 (アロケーションが動的の時) or MCU RAMサイズ/ 4（アロケーションが静的の時）

 6. MAX_TASK_NAME_LEN : タスク名の最大長．12 ~ 255. 

 7. USE_16_BIT_TICKS : Tickカウントの型定義

    Enable : portTickTypeはunsigned 16bit型で定義される（8bit or 16bitマイコン用）

    Disable : portTickTypeはunsigned 32bit型で定義される（STM32は必ずこっち）

8. IDLE_SHOULD_YIELD : アイドル優先度でも実行されるアプリケーションタスクがある場合，IDLE_SHOULD_YIELDはアイドルタスクの挙動を制御する．プリエンプションスケジューラが使用されている場合のみ有効 (Yieldはイールドと読み，意味は譲歩)

   Disable : 下の図の場合，IdleTaskとTask2が同じTickをシェアして動く，途中で優先度の高いTask1がReadyになると，アイドルタスクは同じ優先度のタスクに譲らない（つまり移らない）．

   [![img](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F540259%2F0cc1337c-3f6b-48d0-b88b-93e65ab0fa4c.png?ixlib=rb-1.2.2&auto=format&gif-q=60&q=75&s=47d477ce95a08d831d47ef07f55e917e)](https://camo.qiitausercontent.com/d3874ed2336a53bc648e276d6e170197945b25c9/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f3534303235392f30636331333337632d336636622d343864302d623838622d3933653635616230666134632e706e67)

   Enable :下の図の場合，Idle Taskと同じ優先度のTask2の実行時間を多めに割り当てることができる．これらより優先度の高いタスクが実行された後，Task2の実行に戻る

[![img](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F540259%2F0fa31247-26d0-8c33-e9f9-95c4c0852cee.png?ixlib=rb-1.2.2&auto=format&gif-q=60&q=75&s=26b83367eb34c43cead341c326de3d44)](https://camo.qiitausercontent.com/3fcb3d5cb4c27bcb9cf12c82214f868c767cb357/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f3534303235392f30666133313234372d323664302d386333332d653966392d3935633463303835326365652e706e67)

 9. USE_MUTEXES

 10. USE_RECURSIVE_MUTEXES

 11. USE_COUNTING_SEMAPHORES

 12. QUEUE_REGISTRY_SIZE (0-255)

     Queueレジストリは2つの目的を持ち，どちらもRTOSカーネル対応デバッグに関連する．

     1. デバッグGUIを使用してキューを簡単に識別できるように、テキスト名をキューに関連付けることができます。
     2. これには、登録されている各キューとセマフォを見つけるためにデバッガーが必要とする情報が含まれています。

     カーネル対応デバッガーを使用していない限り、キューレジストリには目的がありません。

 13. USE_APPLICATION_TASK_TAG

     vTaskSetApplicationTaskTag関数を有効にするために，この値は1にセットされる必要がある．

 14. ENABLE_BACKWARD_COMPATIBILITY

 15. USE_POST_OPTIMISED_TASK_SELECTION

 16. USE_TICKLESS_IDLE

 17. USE_TASK_NOTIFICATIONS

 18. RECODE_STACK_HIGH_ADDRESS

#### Memory management settings

1. Memory Allocation
2. TOTAL_HEAP_SIZE
3. Memory Management scheme

#### Hook function related definitions

1. USE_IDLE_HOOK
2. USE_TICK_HOOK
3. USE_MALLOC_FAILED_HOOK
4. CHECK_FOR_STACK_OVERFLOW

#### Run time and task stats gathering related definitions

1. GENERATE_RUN_TIME_STATS
2. USE_TRACE_FACILITY
3. USE_STATS_FORMATTING_FUNCTIONS

#### Co-routine related definitions

1. USE_CO_ROUTINES
2. MAX_CO_ROUTINE_PRIORITIES

#### Software timer definitions

1. USE_TIMERS
2. TIMER_TASK_PRIORITY
3. TIMER_QUEUE_LENGTH
4. TIMER_TASK_STACK_DEPTH

#### Interrupt nesting befaviour configuration

1. LIBRARY_LOWEST_INTERRUPT_PRIORITY
2. LIBRARY_MAX_SYSCAL_INTERRUPT_PRIORITY

#### Added with 10.2.1 suuport 

1. MESSAGE_BUFFER_LENGTH_TYPE
2. USE_POSIX_ERRNO

#### CMSIS-RTOS V2 flags

1. USE_OS2_THREAD_SUSPEND_RESUME
2. USE_OS2_THREAD_ENUMERATE
3. USE_OS2_EVENTFLAGS_FROM_ISR
4. USE_OS2_THREAD_FLAGS
5. USE_OS2_TIMER
6. USE_OS2_MUTEX

## 姿勢推定(IMU)

### そもそも論

- ヨー角は3軸加速度センサだけでは推定できない（姿勢を推定する指標にいなる重力加速度がZ軸＝ヨー軸を貫いているため）

  - ヨー角を補正するためには磁気センサが必要（つまり9軸センサでなければならない），だが精度は悪い

    [9軸センサで相補フィルタ使って姿勢推定](https://qiita.com/Tanba28/items/5092c3e5e2c631b804f3)

  - 逆に，6軸センサでヨー角を補正するとなると，経験則でフィルタをかける必要がある．
  - 

#### 相補フィルタ

- ジャイロにHPF，加速度にLPFをかけて，それらを組み合わせて角度をいい感じに推定する

- パラメータ変動がしないため，静的フィルタ

  [yuqlid wiki 相補フィルタ](https://yuqlid.sakura.ne.jp/dokuwiki/doku.php?id=相補フィルタ)

#### カルマンフィルタ

- 線形モデルに対応

- [6軸IMU 拡張カルマンフィルタ](https://memo.soarcloud.com/6軸imu～拡張カルマンフィルタ/)

#### 拡張カルマンフィルタ

- 非線形モデルに対応

#### DMP



## モータ制御



## 走行制御





## 探索アルゴリズム



## 経路計画 



## 走行シミュレータ

## タスク設計

1. VelocityControlTask

   速度制御タスク

   入力：目標車体速度，目標車体角速度（キューで取得）

   出力：各モータPWM Duty

   サンプリング周期が早いため，一番高い優先度．

   周期：2msくらい？

   

2. TrajectoryControlTask

   軌道制御タスク

   軌道に追従させるように位置フィードバッグ制御を行う

   入力：目標位置，目標角度（キューで取得）

   出力：目標車体速度，目標車体角速度（キューで送信）

   周期：5~10msくらい？

   優先度は2番目に高い

   

3. WallDetectTask

   壁検出タスク

   壁を検出して，現在のロボットの周辺○ｍｍ以内の壁情報（有無）を出力する（とりあえず最初は前方と左右）

   周期：10〜20msくらい

   優先度はそこそこ高め

   

4. MainTask

   - 自己位置推定
     - ロータリーエンコーダ（座標）とIMU（姿勢）から推定
     - ありえない座標や姿勢の場合はエラー状態に落とす（速度制御や軌道制御のタスクは一時停止する）
   - 軌道生成
     - 時間ベースで更新されていく
     - 探索時はほぼ一定速度and足立式
     - 探索後はマップ情報をもとに作成
   - マップ生成
     - 壁検出タスクからの壁情報をもとに，マップを生成していく
   - 迷路探索
     - 足立式
     - 壁情報をもとに，次に進む方向を決定する

   周期：5~10msくらい？

   

5. DebugTask

   PCとのシリアル通信を使用して，デバッグ出力する

   

   各タスクからの送信データをQueueで受け取り，これを取り出して出力する

   タイムスタンプは，各タスクにてQueueにデータを格納した時に自動で付与する

   イベントドリブンの場合

   ​	Queueにデータを格納したタスクがイベント通知し，Queueに溜ったデータを取り出して動く

   サンプリング周期はどのタスクにも対応させるために1ｍｓとするが，優先度は低め

   

6. LedBlinkTask

   そもそもこのタスクはいらない・・・？

   このタスクが，他のタスクの状態を監視・・・？

   スタート状態：

   Running状態

   バッテリー切れ状態：

   これは別→異常状態（自己位置がありえない座標にいる，センサの値が取れないなど）

### ROS & Docker

https://nha6ki.hatenablog.com/entry/2020/10/29/182007

Dockerを使ってROSを動かすことができたが，USB-Serialが認識されず断念

Parallels DesktopもBluetoothデバイスが認識されず，これも断念

マウスのリアルタイム位置描画はやめたほうがいいかもしれない（ログさえ手に入れば良いため）



# メカ

### Fusion360



### モータマウント

